import "std:core.zpp";
import "std:io.zpp";
import "std:cstring.zpp";
import "std:string_parse.zpp";
import "std:memregion.zpp";
import "std:fmtstring.zpp";
import "std:math.zpp";

export type Circle = (radius: f64);
export type Rectan = (side1: f64, side2: f64);
export type ShapeValue = Circle | Rectan;
export type Shape = (
  -- struct stuff
  tag: u8,
  value: ShapeValue,

  -- interface: Representatable
  irepr: fn (MemRegion, ShapeValue) FmtString,
  -- interface: AreaCalculable
  icompute_area: fn (ShapeValue) FmtString
);

export const ShapeTagCircle = 0;
export const ShapeTagRectan = 1;

export fn box_circle(circle: Circle) boxed: Shape {
  quit boxed = (
    -- struct stuff
    tag: ShapeTagCircle,
    value: box!(circle),

    -- interface implementation for Representatable
    irepr: circle_irepr_impl,
    -- interface implementation for AreaCalculable
    icompute_area: circle_icompute_area_impl
  );
}

export fn box_rectan(rectan: Rectan) boxed: Shape {
  quit boxed = (
    -- struct stuff
    tag: ShapeTagRectan,
    value: box!(rectan),

    -- interface implementation for Representatable
    irepr: rectan_irepr_impl,
    -- interface implementation for AreaCalculable
    icompute_area: rectan_icompute_area_impl
  );
}

export fn circle_irepr_impl(region: MemRegion, boxed_circle: ShapeValue) repr: FmtString {
  let circle: Circle = unbox!(boxed_circle);
  quit repr = fmt!(region, "Circle(radius: %f64)", circle.radius);
}

export fn rectan_irepr_impl(region: MemRegion, boxed_rectan: ShapeValue) repr: FmtString {
  let rectan: Rectan = unbox!(boxed_rectan);
  quit repr = fmt!(region, "Rectan(side1: %f64, side2: %f64)", rectan.side1, rectan.side2);
}

export fn shape_repr(region: MemRegion, shape: Shape) repr: FmtString {
  quit repr = ptrcall!(shape.irepr, region, shape.value);
}

export fn circle_icompute_area_impl(boxed_circle: ShapeValue) area: f64 {
  let circle: Circle = unbox!(boxed_circle);
  quit area = Pi * pow(circle.radius, 2);
}

export fn rectan_icompute_area_impl(boxed_rectan: ShapeValue) area: f64 {
  let rectan: Rectan = unbox!(boxed_rectan);
  quit area = rectan.side1 * rectan.side2;
}

export fn compute_area(shape: Shape) area: f64 {
  quit area = ptrcall!(shape.icompute_area, shape.value);
}

const Usage = constcat!(
  "usage: area-calc <shape-name> <shape-properties>\n\n",

  "examples:\n",
  "  + circle 10\n",
  "  + rectan 20 30\n"
);

fn main(argc: u32, argv: **u8) exit: u8 {
  exit = 0;

  if (argc == 1) {
    print(Usage);
    quit exit = 1;
  }

  let region = create_auto_mem_region();
  defer drop_auto_mem_region(&region);

  let shape_name = argv[1];
  let shape = if (cstring_eq(shape_name, "circle")) t: Shape {
    if (argc != 3) {
      print("only expected radius after 'circle'");
      quit exit = 1;
    }

    if (!parse_string_to_float::<f64>(argv[2], let radius)) {
      print("expected radius to be 'f64'");
      quit exit = 1;
    }

    quit t = box_circle((radius: radius));
  } elif (cstring_eq(shape_name, "rectan")) {
    if (argc != 4) {
      print("only expected side1 and side2 after 'rectan'");
      quit exit = 1;
    }

    if (
      !parse_string_to_float::<f64>(argv[2], let side1) or
      !parse_string_to_float::<f64>(argv[3], let side2)
    ) {
      print("expected side1 and side2 to be 'f64'");
      quit exit = 1;
    }

    quit t = box_rectan((side1: side1, side2: side2));
  } else {
    printf(fmt!(region, "unknown shape: '%s'\n", shape_name));
    quit exit = 1;
  };

  printf(fmt!(region, "compute_area(%s): %s", shape_repr(region, shape), compute_area(shape)));
}