from '../modules/sys.zpp' import [ Error, Ok, Err ]

test 'and':
  a: u8 = true
  b: u8 = true
  c: u8 = false

  if a and b and c:
    return Err
  
  if a and c:
    return Err
  
  if b and c:
    return Err

test 'and2':
  n: u8 = true

  if false and n:
    return Err

test 'array':
  a: [3 x i32] = [1, 2, 3]
  b: *[3 x i32] = &a
  c: *mut i32 = b as *mut i32

  a[0] = 2
  (*b)[1] = 3
  c[2] = 4

  if a[0] + a[1] + a[2] != 9:
    return Err

test 'bool':
  x: u8 = true
  y: u8 = false

  if x or y:
    return Ok
  
  if y or x:
    return Ok
  
  return Err

test 'bool2':
  x: u8 = false
  y: u8 = false

  if x or y:
    return Err
  
  if y or x:
    return Err

test 'chr':
  x: u8 = `a`
  y: i32 = `b`

  if y - x as i32 != 1:
    return Err

from '../modules/libc.zpp' import [ malloc, free ]

test 'defer':
  x: *mut u8 = malloc(type_size!(|i32|))
  defer free(x)

  *(x as *mut i32) = 2

  -- in return expression is still available
  -- it means the free is called just before
  -- the terminator (return instruction)
  return Ok if *(x as *i32) == 2 else Err

-- iterative fibonacci
fn ifib(n: u16) -> u64:
  a: u64 = 0
  b: u64 = 1

  for .., n > 0, n -= 1:
    t: u64 = a

    a = b
    b = t + b

  return a

-- recursive fibonacci
fn rfib(n: u16) -> u64:
  return n as u64 if n <= 1 else rfib(n - 1) + rfib(n - 2)

test 'iterative fib + recursive fib':
  return Ok if ifib(20) + rfib(15) == 7375 else Err

test 'forloop':
  i: u32 = 0
  for .., i < 10, i += 1:
    pass
  
  return Ok if i == 10 else Err

test 'floating points':
  x: f32 = 1.2
  y: i32 = (x + 0.8) as i32
  z: f64 = y as f64 + 0.1
  k: u64 = x as u64 + z as u64
  r: u8 = k == 3

  if x == 1.2:
    if y == 2:
      if z == 2.1:
        if r:
          return Ok
  
  return Err

fn add(|T| a: T, b: T) -> T:
  return a + b

test 'generic function':
  a: u8 = add(|u8| 1, 2)
  b: i32 = add(|i32| 3, 4)

  return Ok if a as i32 + b + 1 == 11 else Err

type Node[T] = (data: T, next: *Node[T])

test 'generic type':
  b: Node[i32] = (data: 2, next: null)
  a: Node[i32] = (data: 1, next: &b)
  
  return Ok if a.data + a.next->data == 3 else Err

from 'libs/module_to_import2.zpp' import [ stdout, stderr, do_something_with_fd ]

test 'global variables':
  do_something_with_fd(stdout)
  do_something_with_fd(stderr)

  return Ok if stdout + stderr == 3 else Err

test 'elif statement':
  argc: u32 = 2

  if argc == 1:
    return Err
  elif argc == 2:
    return Ok
  else:
    return Err

test 'nested if statement':
  argc: u32 = 2

  if argc > 1:
    if argc == 2:
      return Ok
    else:
      return Err
  else:
    return Err

test 'inline if':
  a: u8 = true or false

  return Ok if a else Err

from '../modules/seq.zpp' import [ String, Array ]

type Vec3 = (x: u64, y: u64, z: u64)

test 'literals of any type':
  ThisIsConst: *u8 = 'this must be a comptime value'
  Size: u64 = 2

  s: *u8 = 'hello world' -- this points to the data segment
  y: String = 'sized literal string' -- this also points to it
  c: u8 = `c`
  i: i32 = -1
  u: u64 = 1
  f: f32 = 3.14
  k: i32 = undefined -- not assigned (potentially any value)
  v: Vec3 = (x: 1, y: 2, z: 3)
  w: Vec3 = v
  a: [Size x i32] = [1, 2] -- static array
  b: Array[i32] = (ptr: &a as *i32, len: 2) -- sized array
  o: Array[i64] = &[1, 2, 3]
  
  s = 'goodbye'
  i = true
  u = `i`
  c = null
  f = false
  f = null

  -- the `undefined` value can also be passed to function calls 
  -- (it`s actually a value coercable to any type)
  x: i32 = add(|i32| 1, undefined)

  if x == 1:
    pass
  else:
    pass
  
  -- we can discard non-void values
  .. = 1

  return Ok if y.len + u == 125 else Err

test 'num literals':
  x: i32 = 1'000'000
  y: f32 = 1'000'000.2
  
  return Ok if x + y as i32 == 2'000'000 else Err

fn foo(x: i64) -> u8:
  return 12

fn bar() -> Error:
  return Ok

test 'fn ptr':
  x: *fn(i64) -> u8 = fn2ptr!(foo)

  if invoke!(x, 10) != 12:
    return Err

test 'fn ptr2':
  y: *fn() -> Error = fn2ptr!(bar)
  try invoke!(y)

test 'not':
  a: u8 = true
  
  if not a:
    return Err

test 'not2':
  a: u8 = false

  if a:
    return Err
  
  if not a:
    return Ok
  else:
    return Err

test 'or':
  a: u8 = false
  b: u8 = true
  c: u8 = false

  if a or c:
    return Err

  if a or b or c:
    return Ok

  return Err

test 'pointers':
  x: u8 = 0
  y: *mut u8 = &mut x
  z: *u8 = &x
  w: *i32 = &10
  -- k: *mut u8 = &mut 10 -- temporary expression allocation address cannot be mutable

  x = 2
  x += 1
  *y = *z
  -- *z = 1 -- unable to write to unmutable pointer
  
  if x != 3:
    return Err
  
  if *y != *z:
    return Err

-- iterative pow
fn ipow(base: u64, exp: u16) -> u64:
  r: u64 = 1

  for .., exp > 0, exp -= 1:
    r *= base

  return r

-- recursive pow
fn rpow(base: u64, exp: u16) -> u64:
  return 1 if exp == 0 else base * rpow(base, exp - 1)

test 'iterative pow + recursive pow':
  return Ok if ipow(10, 2) + rpow(10, 3) == 1100 else Err

test 'ptr array access':
  argv: **u8 = &['hello', 'world']

  if argv[0][0] != `h`:
    return Err
  
  if argv[1][0] != `w`:
    return Err

type Couple = (a: u8, b: u8)

test 'ptr array access2':
  a: Couple = (a: 1, b: 2)
  b: Couple = (a: 3, b: 4)

  ab: **Couple = &[&a, &b]
  
  if (ab[0]->a + ab[0]->b) * (ab[1]->a + ab[1]->b) != 21:
    return Err

test 'static array':
  a: [3 x i32] = [1, 2, 3]
  b: *[3 x i32] = &a
  c: *i32 = b as *i32
  
  if a[0] + (*b)[1] + c[2] != 6:
    return Err

test 'str from array of chars':
  x: *u16 = &[`a`, `b`, `c`]
  -- using `u16` instead of `u8` to avoid overflow when adding together the chars

  if x[0] + x[1] + x[2] != `a` + `b` + `c`:
    return Err

fn hash_string(s: *String) -> u64:
  result: u64 = 0

  for i: u64 = 0, i < s->len, i += 1:
    result += s->ptr[i] as u64
  
  return result

test 'hashing String manually (iterating over String)':
  if hash_string(&'hello world') != 1116:
    return Err

test 'cstring indexing':
  x: *u8 = 'abc'

  -- casting each term to avoid overflow
  -- if we do `(x[0] + x[1] + ..) as i32` we have UB
  if x[0] as i32 + x[1] as i32 + x[2] as i32 != 294:
    return Err

type Person = (name: *u8, age: u8)

test 'struct constructions and field access':
  person: Person = (name: null, age: 2)
  person2: Person = (name: null, age: 1) -- inferred
  
  if person.age + person2.age != 3:
    return Err

test 'struct construction and field access2':
  x: (a: i32, b: (k: i32, w: i32)) = (a: 0, b: (k: 1, w: 2))
  x.a += 1
  x.b.k = 2
  x.b.w *= 3

  if x.b.k + x.b.w != 8:
    return Err

type K = (m: i32, n: i32)
type R = (a: i32, b: (k: i32, w: *K))

test 'struct construction and field access3':
  t: K = (m: 2, n: 3)
  x: R = (a: 0, b: (k: 1, w: &t))
  y: *R = &x

  if y->b.k + (y->b.w->m * y->b.w->n) != 7:
    return Err

SomeError: Error = 1

test 'must success':
  try Ok

test 'also must success':
  pass

test 'must fail':
  e: Error = SomeError

  try e:
    return Ok
  
  return SomeError

Overflow: Error = 1
Underflow: Error = 2

-- there is a internal function for this (see `add_with_overflow`)
fn add_with_overflow(|T| a: T, b: T, result: *mut T) -> Error:
  *result = a + b

  if a > 0 and b > 0 and *result < 0:
    return Overflow

  if a < 0 and b < 0 and *result > 0:
    return Underflow
  
  -- everything worked
  return Ok

test 'try add_with_overflow (should overflow)':
  try e: Error = add_with_overflow(|i32| 2147483647, 2, out result: i32):
    if e != Overflow and e != Underflow:
      return -1
    
    return Ok
  
  return Err

test 'try try_with_overflow2 (should not overflow)':
  try add_with_overflow(|i32| 1, 2, out result: i32)

  if result != 3:
    return Err

test 'undefined literal':
  x: i32 = undefined
  y: String = undefined

test 'while loop':
  i: u32 = 0
  while i < 10:
    i += 1

  while i > 0:
    i -= 1

  if i != 0:
    return Err
