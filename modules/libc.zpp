--
-- allocate space for 'size_bytes' on to the heap
-- return a nullable pointer
--
fn malloc(size_bytes: u64) -> *mut u8:
  return internal_call!(|u64, *mut u8| "malloc", size_bytes)

--
-- [UB: when 'ptr' is not a valid pointer to the heap]
-- release space of 'ptr'
--
fn free(ptr: *mut u8) -> void:
  internal_call!(|*mut u8, void| "free", ptr)

--
-- print 'buffer' (a null terminated buffer) to stdout
-- return 0 when everything worked
--
fn puts(buffer: *u8) -> i32:
  return internal_call!(|*u8, i32| "puts", buffer)

--
-- [NOTE: this function does not return]
-- close the process
-- %errorlevel%, $? -> exit_code
--
fn exit(exit_code: i32) -> void:
  internal_call!(|i32, void| "exit", exit_code)
  -- todo: implement unreachable!()

--
-- return the length of a cstr (null terminated buffer)
--
fn strlen(cstr: *u8) -> u64:
  return internal_call!(|*u8, u64| "strlen", cstr)

--
-- [UB: when 'target' is not a valid pointer]
-- copy 'buffer_size' bytes from 'source' into 'target'
--
fn memcopy(source: *u8, target: *mut u8, buffer_size: u64) -> void:
  internal_call!(|*mut u8, *u8, u64, void| "memcpy", target, source, buffer_size)

--
-- source: sequence of elements
-- elem_size: size in bytes of each element in source
-- source_len: number of elements in source (NOT: buffer lenght of source in bytes)
-- file_stream: wrap of c 'FILE*'
--
fn fwrite(source: *u8, elem_size: u64, source_len: u64, file_stream: *u8) -> u64:
  return internal_call!(|*u8, u64, u64, *u8, u64| "fwrite", source, elem_size, source_len, file_stream)

--
-- [NOTE: this is actually a property because we can't wrap a global variable]
-- return the stdout buffer
--
fn get_stdout() -> *u8:
  return extern_call!(|*u8| "libs/libchelper.o", "get_stdout")
